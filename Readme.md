# Zombie Survival Game

## Description
This part is all about displaying your mastery of the various topics covered throughout the semester. You will program the AI for a player agent in a zombie survival game provided to you by the teachers. 

The agent has limited information about its surroundings. It has a rough knowledge about the world in general and the entities within its line of sight. It’s up to you to put this information to good use. 

The goal of the agent is to survive for as long as possible and get a high score. Your success depends on your ability to collect and use the helpful items scattered throughout the world and the way you handle the threat of the roaming enemy zombies.

Use the tools given to you, the concepts you’ve seen during class and other topics you’ve researched on your own. Besides having a fully working agent you will also explain its architecture on your exam presentation. In this presentation you will explain to us how you’ve built your agent, what the agent is capable of and how well it performs.

## Stages & score
The game consists of multiple stages, each more difficult than the last. Every stage lasts 60 seconds and has its own number and composition of enemies and items. Stronger enemies will become more likely to spawn in later stages and useful items less likely. Starting in stage 3, “Purge Zones” will start to spawn. These will kill everything within range after a delay. They add another layer of complexity to your exploration behavior, but possibly also opportunities to find areas without zombies! 

Additionally, your agent will get a score based on a reward and penalty system. Both the score and the stage you’ve reached serve as an indicator for the quality of your AI and as a metric to compare and compete with your fellow students! There will be a high scores channel on the official Discord server to share your progress.

### Some scoring tips:
Positive score is added for the following actions:

- Each second you survive: 1
- Killing/Hitting zombies : 15 for each kill, 5 for each hit
- Picking up items: 2

Negative score is given for:
- Missing shots: -5 (a shotgun needs to miss all its shots to be counted as a miss) 
 
## Project Requirements
For the implementation of the AI agent you must use the following techniques:
- 	At least one decision making structure (FSM, Behavior Tree, ...)
- 	Movement logic (steering behaviors, combined steering behaviors, ...)

Students are permitted to use the framework implementations of the above techniques. 

Any custom implementations or extra’s will be rewarded. A custom technique could count as a research topic for the other part of the exam.

## Evaluation criteria
-	Agent
    - World exploration
    - Movement *(steering behaviors, combined steering)*
    - Item handling
    - Enemy handling
    - Decision making
    - Extra(s)
- Code quality & structure
- Knowledge / insight: 
    - Answering questions about the written code and the topics covered in class
- GitHub Usage
    - Regular commits
    - Commit messages

# additional documentation
IExamInterface Functions  WorldInfo World_GetInfo() const; //Returns a WorldInfo structure which contains world information (see Exam_HelperStructs.h)  StatisticsInfo World_GetStats() const; //Returns a StatisticsInfo structure which contains several useful game statistics (see Exam_HelperStructs.h)  bool Fov_GetHouseByIndex(UINT index, HouseInfo& houseInfo) const; //Used to retrieve the HouseInfo from houses inside the FOV (see Exam_HelperStructs.h) //Return TRUE: HouseInfo found for given index //Return FALSE: No HouseInfo found for given index (= no more houses after this index) > Use Plugin::GetHousesInFOV() which uses this function, but returns a vector of HouseInfos  bool Fov_GetEntityByIndex(UINT index, EntityInfo& enemyInfo) const; //Used to retrieve the EntityInfo from entities (items & enemies) inside the FOV (see Exam_HelperStructs.h) //Return TRUE: EntityInfo found for given index //Return FALSE: No EntityInfo found for given index (= no more entities after this index) > Use Plugin::GetEntitiesInFOV() which uses this function, but returns a vector of EntityInfos  AgentInfo Agent_GetInfo() const; //Returns a AgentInfo structure which is packed with crucial agent parameters (see Exam_HelperStructs.h)  bool Enemy_GetInfo(EntityInfo entity, EnemyInfo& enemy); //Used to retrieve some additional information about an enemy (Type, Health, ...) //Returns TRUE: Enemy with given entityHash found. EnemyInfo is set. //Returns FALSE: No enemy found. Note that enemies receive new hashes between frames, using the same entityHash the next frame won’t work.  Vector2 NavMesh_GetClosestPathPoint(Vector2 goal) const; //Returns the next point of the path towards the given goal, using the Navigation Mesh  bool Item_GetInfo(EntityInfo entity, ItemInfo& item); //Use this function to inspect an item (EntityInfo > ItemInfo). You can use this ItemInfo to request more information about the item using the Weapon_GetAmmo, Medkit_GetHealth and FOood_GetEnergy function //The function uses the EntityHash to lookup the corresponding Item  bool Item_Grab(EntityInfo entity, ItemInfo& item); //Use this function to grab an item/entity (EntityInfo > ItemInfo) //The function uses the EntityHash to lookup the corresponding Item, items must be inspected and added to the inventory during the same frame. //The EntityInfo argument is ignored when DebugParams.AutoGrabClosestItem is active  bool Item_Destroy(EntityInfo entity); //Use this function to destroy an entity (only items) //The function uses the EntityHash to lookup the corresponding Item, item must be in FOV and grabrange of the agent  int Weapon_GetAmmo(ItemInfo& item); //Use this function to request the amount of ammo an item of type [PISTOL] has. //This function can be used with items from the inventory or items still on the ground (not yet picked up) //Returns -1 if invalid item is used  int Medkit_GetHealth(ItemInfo& item); //Use this function to request the amount of health an item of type [MEDKIT] has. //This function can be used with items from the inventory or items still on the ground (not yet picked up) //Returns -1 if invalid item is used  int Food_GetEnergy(ItemInfo& item); //Use this function to request the amount of energy an item of type [FOOD] has. //This function can be used with items from the inventory or items still on the ground (not yet picked up) //Returns -1 if invalid item is used  bool PurgeZone_GetInfo(EntityInfo entity, PurgeZoneInfo& zone); //Used to retrieve some additional information about a purge zone (Center, Radius) //Returns TRUE: PurgeZone with given entityHash found. PurgeZoneInfo is set. //Returns FALSE: No PurgeZone found.  bool Inventory_AddItem(UINT slotId, ItemInfo item); //This function adds the given item to the inventory @ the given slotid //Given slot must be empty. ItemInfos are acquired through Item_Grab(...)  bool Inventory_RemoveItem(UINT slotId); //Removes the item at the given inventory slot  bool Inventory_GetItem(UINT slotId, ItemInfo& item); //Retrieves the ItemInfo from the item stored at the given inventory slot  bool Inventory_UseItem(UINT slotId); //Use the item at the given inventory slot. Some items can be used, others can’t (Check console output) //Returns false when use fails (because of reasons mentioned in the console) OR when the item ran out of charges (no ammo left)  UINT Inventory_GetCapacity() const; //Returns the inventory capacity (amount of inventory slots)  Vector2 Debug_ConvertScreenToWorld(Vector2 screenPos) const; //Converts a screenposition to worldposition using the camera’s VP  Vector2 Debug_ConvertWorldToScreen(Vector2 worldPos) const; //Converts a worldposition to screenposition using the camera’s VP  bool Input_IsKeyboardKeyDown(InputScancode key) const; //Returns if the specified keyboard key was pressed down  bool Input_IsKeyboardKeyUp(InputScancode key) const; //Returns if the specified keyboard key was released  bool Input_IsMouseButtonDown(InputMouseButton button) const; //Returns if the specified mouse button was pressed down  bool Input_IsMouseButtonUp(InputMouseButton button) const; //Returns if the specified mouse button was released  MouseData Input_GetMouseData(InputType type, InputMouseButton button) const; //Returns the mouse data for the specified mouse button and type.  void Draw_... //Set of Draw commands which can be for debugging/visualization GameDebugParams Several properties can be controlled or overridden by changing the GameDebugParams (see Exam_HelperStructs.h). These are set during the Plugin::InitGameDebugParams call inside the Plugin class. NOTE that these parameters are only used during a debug build, default values are used when running the release version. So these parameters can only be used for debugging purposes, and your final AI should be test with the default values (or in a release build). Include Files The project contains several include files, located in the ‘inc’ folder. These files are ‘shared includes’ which are also used to build the Host-Programs & BasePlugin Library. Altering these include files will (in most cases, depending on what you change and where it is used) result in heavy crashes and/or undefined behavior. It’s important that the structures that are shared between the plugin and host- program are identical. Changing the structures means changing them only for the plugin, and not for the host-program. Files that can’t be changed (none of the include files actually):  inc/Exam_HelperStructs.h  inc/IBaseInterface.h  inc/IExamInterface.h  inc/IExamPlugin.h  inc/IPluginBase.h If you want to extend a structure, create a sub structure that inherits from the original structure. example: Running the project in Debug Mode By default, Visual Studio won’t rebuild the GPP_Exam project since the startup project is the GPP_TEST_DEBUG project and there are no dependencies between both projects. Running the project in Release Mode When you want to run your project in Release, you cannot change the GameDebugParams, so this means it’s not possible to set the Seed from your GPP_Exam code. If you do want to test with different seeds in Release, it is suggested to run your project using the 4WindowExamRunner.bat file in the folder /_DEMO_RELEASE. By opening the .bat file in a text editor, you can set the seed value by changing the number following ‘-s’ in the startup arguments. Tip: “-s 0” will result in a random seed every time. Zombie Survival Game Description: This part is all about displaying your mastery of the various topics covered throughout the semester. You will program the AI for a player agent in a zombie survival game provided to you by the teachers. The agent has limited information about its surroundings. It has a rough knowledge about the world in general and the entities within its line of sight. It’s up to you to put this information to good use. The goal of the agent is to survive for as long as possible and get a high score. Your success depends on your ability to collect and use the helpful items scattered throughout the world and the way you handle the threat of the roaming enemy zombies. Use the tools given to you, the concepts you’ve seen during class and other topics you’ve researched on your own. Besides having a fully working agent you will also explain its architecture on your exam presentation. In this presentation you will explain to us how you’ve built your agent, what the agent is capable of and how well it performs. Stages & score The game consists of multiple stages, each more difficult than the last. Every stage lasts 60 seconds and has its own number and composition of enemies and items. Stronger enemies will become more likely to spawn in later stages and useful items less likely. Starting in stage 3, “Purge Zones” will start to spawn. These will kill everything within range after a delay. They add another layer of complexity to your exploration behavior, but possibly also opportunities to find areas without zombies! Additionally, your agent will get a score based on a reward and penalty system. Both the score and the stage you’ve reached serve as an indicator for the quality of your AI and as a metric to compare and compete with your fellow students! There will be a high scores channel on the official Discord server to share your progress. Some scoring tips: Positive score is added for the following actions: Each second you survive: 1 Killing/Hitting zombies : 15 for each kill, 5 for each hit Picking up items: 2 Negative score is given for: Missing shots: -5 (a shotgun needs to miss all its shots to be counted as a miss)   Project Requirements For the implementation of the AI agent you must use the following techniques: At least one decision making structure (FSM, Behavior Tree, ...) Movement logic (steering behaviors, combined steering behaviors, ...) Students are permitted to use the framework implementations of the above techniques. Any custom implementations or extra’s will be rewarded. A custom technique could count as a research topic for the other part of the exam. Evaluation criteria Agent World exploration Movement (steering behaviors, combined steering) Item handling Enemy handling Decision making Extra(s) Code quality & structure Knowledge / insight: Answering questions about the written code and the topics covered in class GitHub Usage Regular commits Commit messages